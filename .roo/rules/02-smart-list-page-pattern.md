# RooCode: Smart List Page Pattern

## 1. Overview

The **Smart List Page** pattern provides a reusable, flexible, and declarative approach for building list pages (data tables) with filtering, sorting, and pagination capabilities. This pattern abstracts away boilerplate code and supports both client-side and server-side data operations with **automatic filtering** and **unified user experience**.

The pattern consists of:
1. **DataTableConfigBuilder**: Declarative configuration for table structure and behavior
2. **QueryBuilder Service**: Server-side query enhancement with dynamic filtering/sorting and automatic wildcard handling
3. **createListPageLoader Factory**: Generates load functions and actions for `+page.server.ts`
4. **SmartTable Components**: Reusable Svelte 5 components with TanStack Table integration and unified filtering logic
5. **Dual Mode Support**: Client-side (all data loaded) or server-side (paginated queries) with identical user experience
6. **Automatic Filtering**: No manual "Apply" buttons needed - filters work as you type or select

---

## 2. Architecture Components

### Core Files Structure
```
src/routes/(app)/your-route/
├── +page.server.ts          # Server load and actions (generated by factory)
├── +page.svelte             # Simple SmartTable component usage
├── datatable.config.ts      # Table configuration and column definitions
└── edit/[[id]]/             # Edit/create pages (REQUIRED for table actions)
    ├── +page.server.ts      # Smart CRUD implementation
    ├── +page.svelte         # Smart form implementation
    └── entity.payload.ts    # Payload builder for form data
```

### Route Structure Requirements
- **ALL table-based routes MUST use the `edit/[[id]]/` pattern** for create/edit operations
- The `[[id]]` parameter allows the same route to handle both create (no ID) and edit (with ID) modes
- The `DataTableActions` component automatically navigates to `/edit/{id}` for all table rows
- Create button should point to `/your-route/edit` (without ID for create mode)

### Supporting Infrastructure
- **DataTableConfigBuilder**: `src/lib/utils/data-table-config.builder.ts`
- **ListPageFactory**: `src/lib/utils/list-page.factory.ts`
- **QueryBuilder**: `src/lib/services/supabase/query.builder.ts`
- **SmartTable Components**: `src/lib/components/forms/SmartTable*.svelte`

---

## 3. Implementation Steps

### Step 1: Create Table Configuration

Create `datatable.config.ts` in your route directory:

```typescript
// src/routes/(app)/your-route/datatable.config.ts
import { DataTableConfigBuilder, columnTypes } from '$lib/utils/data-table-config.builder';
import type { Tables } from '@tihomir971/assist-shared';
import type { ColumnDef } from '@tanstack/svelte-table';
import DataTableActions from '$lib/components/ui/data-table-actions.svelte';
import { RenderComponentConfig } from '$lib/components/walker-tx/render-component';

// Define your data type (with joins if needed)
export type YourDataType = Tables<'your_table'> & {
  related_table?: { name: string };
};

// Define columns using TanStack Table ColumnDef
const columns: ColumnDef<YourDataType>[] = [
  // IMPORTANT: Always include a column for the 'id' field.
  // It can be hidden, but it's required for row actions to work correctly.
  columnTypes.hiddenId('id'),
  columnTypes.text('name', 'Name'),
  columnTypes.boolean('is_active', 'Active'),
  columnTypes.link('code', 'Code', (row) => `/your-route/${row.id}`),
  // Custom column with snippet
  columnTypes.custom('status', 'Status', statusSnippet),
  // Actions column (requires TypeScript workaround)
  {
    id: 'actions',
    enableColumnFilter: false,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    cell: (props) => new RenderComponentConfig(DataTableActions as any, { props: props })
  }
];

export const yourTableConfig = new DataTableConfigBuilder<YourDataType>()
  .title('Your Items')
  .columns(columns)
  .createButton('Create Item', '/your-route/edit')
  .mode('client') // or 'server'
  .deleteAction('?/delete')
  .addFilter({
    name: 'name',
    label: 'Name',
    type: 'text',
    placeholder: 'Filter by name...',
    field: 'name',        // REQUIRED for server mode
    operator: 'ilike'     // REQUIRED for server mode
  })
  .addFilter({
    name: 'status',
    label: 'Status',
    type: 'select',
    lookupDataKey: 'statusOptions',
    field: 'status_id',
    operator: 'eq',
    dbType: 'number'
  })
  .addFilter({
    name: 'is_active',
    label: 'Active',
    type: 'boolean',
    field: 'is_active',
    operator: 'eq',
    dbType: 'boolean'
  })
  .build();
```

### Step 2: Implement Server Logic

Create `+page.server.ts` using the factory with reactive data loading:

```typescript
// src/routes/(app)/your-route/+page.server.ts
import { createListPageLoader } from '$lib/utils/list-page.factory';
import { yourTableConfig } from './datatable.config';
import { YourService } from '$lib/services/supabase/your.service';

const listPageLoader = createListPageLoader({
  config: yourTableConfig,
  baseQuery: (supabase) =>
    supabase
      .from('your_table')
      .select('*, related_table!inner(name)', { count: 'exact' })
      .order('name'),
  service: YourService,
  lookupData: {
    statusOptions: (service) => service.getStatusLookup(),
    categoryOptions: () => Promise.resolve([
      { value: 1, label: 'Category 1' },
      { value: 2, label: 'Category 2' }
    ])
  }
});

// IMPORTANT: Add depends() for reactive filtering
export const load = async (event) => {
  event.depends('your-section:your-entity'); // e.g., 'crm:contacts'
  return await listPageLoader.load(event);
};

export const actions = listPageLoader.actions;
```

### Step 3: Create Frontend Page

Create `+page.svelte` with minimal code:

```svelte
<!-- src/routes/(app)/your-route/+page.svelte -->
<script lang="ts">
  import SmartTable from '$lib/components/forms/SmartTable.svelte';
  import { yourTableConfig } from './datatable.config';

  let { data } = $props();
</script>

<SmartTable
  data={data.items}
  config={yourTableConfig}
  count={data.count}
  page={data.page}
  perPage={data.perPage}
  deleteForm={data.deleteForm}
  lookupData={data.lookup}
/>
```

---

## 4. Automatic Filtering Behavior

The Smart List Page Pattern now includes **automatic filtering** that eliminates the need for manual "Apply Filters" buttons:

### Client Mode Filtering
- **Text inputs**: Filter instantly as you type
- **Select/Boolean inputs**: Filter immediately on selection change
- **Processing**: All filtering happens in the browser using TanStack Table
- **Performance**: Instant results, no server requests

### Server Mode Filtering
- **Text inputs**: Auto-filter after 500ms typing pause (debounced)
- **Select/Boolean inputs**: Filter immediately on selection change
- **Processing**: Server-side queries with efficient data transfer
- **URL State**: All filters preserved in URL for bookmarking/sharing

### Key Features
- **No "Apply" button needed**: Filters work automatically
- **Debounced text search**: Prevents excessive server requests while typing
- **Wildcard text matching**: Text filters use `%value%` for partial matches
- **Reactive data loading**: Uses SvelteKit's `depends`/`invalidate` pattern
- **Clean UI**: Only "Clear Filters" and "Create" buttons remain

### Filter Configuration
```typescript
.addFilter({
  name: 'display_name',
  label: 'Name',
  type: 'text',           // Auto-debounced in server mode
  placeholder: 'Filter by name...',
  field: 'display_name',  // Database field for server mode
  operator: 'ilike'       // Automatically adds % wildcards
})
.addFilter({
  name: 'is_active',
  label: 'Active',
  type: 'boolean',        // Immediate filtering
  field: 'is_active',
  operator: 'eq',
  dbType: 'boolean'
})
```

---

## 5. Integration with Smart CRUD Pattern

When implementing the Smart List Page Pattern, the edit/create functionality should follow the Smart CRUD pattern:

### Edit Route Implementation
```typescript
// src/routes/(app)/your-route/edit/[[id]]/+page.server.ts
import { createSimpleCRUD } from '$lib/utils/simple-crud.factory';
import { YourEntityService } from '$lib/services/supabase/your-entity.service';
import { yourEntityPayloadBuilder } from './entity.payload.js';
import { mYourEntityInsertSchema } from '@tihomir971/assist-shared';

export const load = async ({ params, locals: { supabase } }) => {
  const isCreateMode = !params.id;
  
  if (isCreateMode) {
    // Create mode logic
    return {
      form: await superValidate(defaultData, zod(createSchema)),
      isCreateMode: true
    };
  } else {
    // Edit mode logic
    const service = new YourEntityService(supabase);
    const entity = await service.getById(parseInt(params.id!));
    return {
      form: await superValidate(entity, zod(updateSchema)),
      isCreateMode: false
    };
  }
};

const crud = createSimpleCRUD(
  'YourEntity',
  (supabase) => new YourEntityService(supabase),
  yourEntityPayloadBuilder,
  mYourEntityInsertSchema
);

export const actions = {
  upsert: crud.upsert,
  delete: crud.delete
};
```

### Payload Builder
```typescript
// src/routes/(app)/your-route/edit/[[id]]/entity.payload.ts
import { SmartPayloadBuilder } from '$lib/utils/smart-payload.builder';
import { mYourEntityInsertSchema, mYourEntityUpdateSchema } from '@tihomir971/assist-shared';

export const yourEntityPayloadBuilder = new SmartPayloadBuilder(
  { schema: mYourEntityInsertSchema, defaults: { is_active: true } },
  { schema: mYourEntityUpdateSchema }
);
```

---

## 5. Configuration Options

### DataTableConfig Properties

```typescript
type DataTableConfig<TData> = {
  title: string;                    // Page/table title
  columns: ColumnDef<TData>[];      // TanStack Table column definitions
  filters: FilterDefinition[];      // Available filters for toolbar
  createButton?: {                  // Optional "Create New" button
    label: string;
    href: string;
  };
  mode: 'client' | 'server';        // Data processing mode
  deleteAction?: string;            // Action path for delete operation
  rowActions?: Snippet<[{ row: TData }]>; // Custom row actions snippet
};
```

### Filter Types

```typescript
type FilterDefinition = {
  name: string;           // URL search param name
  label: string;          // Display label
  type: 'text' | 'select' | 'boolean';
  placeholder?: string;   // Input placeholder
  options?: SelectFilterOption[]; // Static options for select
  lookupDataKey?: string; // Key in lookup data for dynamic options
  field?: string;         // Database field name (if different from name)
  operator?: 'eq' | 'ilike' | 'gte' | 'lte' | 'in'; // Supabase operator
  dbType?: 'number' | 'boolean' | 'array'; // Database type for server-side
};
```

### Column Types Helper

```typescript
const columnTypes = {
  hiddenId: (accessorKey = 'id') => ({
    accessorKey,
    header: 'ID',
    enableColumnFilter: false,
    enableSorting: false,
    meta: {
      className: 'hidden'
    }
  }),
  text: (accessorKey, header) => ({ accessorKey, header }),
  boolean: (accessorKey, header) => ({
    accessorKey,
    header,
    cell: ({ cell }) => (cell.getValue() ? 'Yes' : 'No')
  }),
  link: (accessorKey, header, hrefBuilder) => ({
    accessorKey,
    header,
    cell: ({ row, getValue }) => {
      const value = getValue();
      const href = hrefBuilder(row.original);
      return `<a href="${href}">${value}</a>`;
    }
  }),
  custom: (accessorKey, header, cellSnippet) => ({
    accessorKey,
    header,
    cell: ({ row, cell }) => cellSnippet({ row: row.original, cell: cell.getValue() })
  })
};
```

---

## 5. Mode Differences

### Client Mode (`mode: 'client'`)
- **Data Loading**: Fetches ALL data in the load function
- **Processing**: Filtering, sorting, and pagination handled by TanStack Table in browser
- **Performance**: Good for small to medium datasets (< 1000 records)
- **URL State**: Filters not reflected in URL
- **Real-time**: Instant filtering and sorting

### Server Mode (`mode: 'server'`)
- **Data Loading**: Fetches only current page of data
- **Processing**: Filtering, sorting, and pagination handled by Supabase queries
- **Performance**: Excellent for large datasets (> 1000 records)
- **URL State**: All filters, sorting, and pagination reflected in URL
- **Navigation**: Page refreshes on filter/sort changes

---

## 6. Service Requirements

Your service class must implement the `ServiceWithDelete` interface:

```typescript
// src/lib/services/supabase/your.service.ts
import type { SupabaseClient } from '@supabase/supabase-js';
import type { Database } from '@tihomir971/assist-shared';

export class YourService {
  constructor(public supabase: SupabaseClient<Database>) {}

  async delete(id: number): Promise<void> {
    const { error } = await this.supabase
      .from('your_table')
      .delete()
      .eq('id', id);
    
    if (error) throw error;
  }

  async getStatusLookup(): Promise<SelectFilterOption[]> {
    const { data } = await this.supabase
      .from('status_table')
      .select('id, name')
      .eq('is_active', true);
    
    return data?.map(item => ({ 
      value: item.id, 
      label: item.name 
    })) || [];
  }
}
```

---

## 7. Advanced Features

### Custom Row Actions

```typescript
// In datatable.config.ts
import { snippet } from 'svelte';

const rowActionsSnippet = snippet<[{ row: YourDataType }]>(({ row }) => {
  return `
    <div class="flex gap-2">
      <Button href="/your-route/${row.id}">Edit</Button>
      <Button variant="destructive" onclick={() => deleteItem(row.id)}>Delete</Button>
    </div>
  `;
});

export const yourTableConfig = new DataTableConfigBuilder<YourDataType>()
  // ... other config
  .rowActions(rowActionsSnippet)
  .build();
```

### Complex Filtering

```typescript
// Server-side filtering with relationships
.addFilter({
  name: 'category_name',
  label: 'Category',
  type: 'select',
  lookupDataKey: 'categories',
  field: 'category_id',        // Database field to filter on
  operator: 'eq',              // Supabase operator
  dbType: 'number'             // Type conversion for query
})
```

### Custom Cell Rendering

```typescript
// Using Svelte snippets for complex cell content
const statusSnippet = snippet<[{ row: YourDataType; cell: string }]>(({ row, cell }) => {
  const statusClass = cell === 'active' ? 'text-green-600' : 'text-red-600';
  return `<span class="${statusClass}">${cell}</span>`;
});

const columns: ColumnDef<YourDataType>[] = [
  columnTypes.custom('status', 'Status', statusSnippet)
];
```

---

## 8. Best Practices

### Performance Guidelines
- **Use client mode** for datasets < 1000 records
- **Use server mode** for datasets > 1000 records
- **Optimize base queries** with proper indexes and selective joins
- **Limit select fields** to only what's needed for display

### Configuration Organization
- **Co-locate configs** in the route directory they're used in
- **Type your data** with proper TypeScript interfaces including joins
- **Use lookup data** for dynamic filter options rather than hardcoded arrays
- **Keep column definitions** focused and reusable

### URL State Management
- **Server mode** automatically manages URL state for filters/sorting
- **Client mode** doesn't persist state in URL (by design for performance)
- **Deep linking** works automatically in server mode

### Error Handling
- **Service errors** are automatically caught and returned as 500 responses
- **Validation errors** are handled by the delete form validation
- **Query errors** are logged and throw appropriate HTTP errors

---

## 9. Migration from Existing Tables

### From Custom Table Components
1. **Extract column definitions** into `ColumnDef[]` format
2. **Convert filter logic** to `FilterDefinition[]` configuration
3. **Move server logic** to use `createListPageLoader` factory
4. **Replace component** with `SmartTable`

### From Walker-TX Tables
1. **Keep existing column definitions** (they're compatible)
2. **Add filter configurations** using the new `FilterDefinition` format
3. **Update server logic** to use the factory pattern
4. **Gradually migrate** one table at a time

---

## 10. Troubleshooting

### Common Issues

**Filters not working in server mode:**
- Ensure `field` and `operator` are specified in filter definition
- Check that the field exists in your base query
- Verify `dbType` matches the actual database column type

**Sorting not working:**
- Ensure column `accessorKey` matches database field name
- Check that field is included in `sortableFields` array (auto-generated from columns)

**Pagination showing wrong counts:**
- Verify your base query includes `.count()` for server mode
- Check that the service delete method properly removes records

**Row actions (edit/delete) not working on paginated pages:**
- Ensure you have included a column for the `id` field in your `columns` definition. It can be hidden using `columnTypes.hiddenId('id')`. This is required for TanStack Table to correctly identify rows.

**TypeScript errors:**
- Ensure your data type includes all joined table fields
- Use proper generic types in `DataTableConfigBuilder<YourType>`
- Import all required types from the correct modules
- **DataTableActions component**: Use `as any` workaround for component typing: `new RenderComponentConfig(DataTableActions as any, { props: props })`

**Payload Builder type mismatches:**
- Always use the base Zod schemas from `$lib/types/supabase.zod.schemas` (e.g., `mYourEntityInsertSchema`)
- Avoid using complex schemas with additional fields in payload builders
- The `SmartPayloadBuilder` expects simple insert/update schemas, not extended ones with relationships

### Performance Issues

**Slow loading in client mode:**
- Consider switching to server mode for large datasets
- Optimize your base query with proper indexes
- Reduce the number of joined tables or selected fields

**Slow filtering in server mode:**
- Add database indexes for filtered columns
- Optimize your `QueryBuilder` filter logic
- Consider caching lookup data